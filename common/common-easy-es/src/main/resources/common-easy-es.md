# Easy Es 简介

Easy-Es（简称 `EE`）是一款基于 ElasticSearch(简称Es) 官方提供的 `RestHighLevelClient` 打造的 ORM 开发框架，在 RestHighLevelClient 的基础上, 只做增强，不做改变，为简化开发、提高效率而生, 您如果有用过 Mybatis-Plus(简称MP), 那么您基本可以 `零` 学习成本直接上手 EE, EE 是 MP 的 Es 平替版, 在有些方面甚至比 MP 更简单, 同时也融入了更多 Es 独有的功能, 助力您快速实现各种场景的开发。

## Easy Es 理念

> 把简单, 易用, 方便留给用户, 把复杂留给框架

## Easy Es 愿景

> 让天下没有难用的 Es, 致力于成为全球最受欢迎的 ElasticSearch 搜索引擎开发框架.

## Easy Es 优势

- 全自动索引托管: 全球开源首创的索引托管模式, 开发者无需关心索引的创建更新及数据迁移等繁琐步骤, 索引全生命周期皆可托管给框架, 由框架自动完成, 过程零停机, 用户无感知, 彻底解放开发者
- 屏蔽语言差异: 开发者只需要会 MySQL 语法即可使用 Es, 真正做到一通百通, 无需学习枯燥易忘的 Es 语法, Es 使用相对 MySQL 较低频, 学了长期不用也会忘, 没必要浪费这时间. 开发就应该专注于业务, 省下的时间去撸铁, 去陪女朋友陪家人, 不做资本家的韭菜
- 代码量极少: 与直接使用 RestHighLevelClient 相比, 相同的查询平均可以节省 3-5 倍左右的代码量
- 零魔法值: 字段名称直接从实体中获取, 无需输入字段名称字符串这种魔法值, 提高代码可读性, 杜绝因字段名称修改而代码漏改带来的 Bug
- 零额外学习成本: 开发者只要会国内最受欢迎的 Mybatis-Plus 语法, 即可无缝迁移至 EE, EE 采用和前者相同的语法, 消除使用者额外学习成本, 直接上手, 爽
- 降低开发者门槛: Es 通常需要中高级开发者才能驾驭, 但通过接入 EE, 即便是只了解 ES 基础的初学者也可以轻松驾驭 ES 完成绝大多数需求的开发, 可以提高人员利用率, 降低企业成本

## Easy Es 特性

- 无侵入：只做增强，不做改变，引入它不会对现有工程产生影响，如丝般顺滑
- 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作
- 强大的 CRUD 操作：内置通用 Mapper，仅仅通过少量配置即可实现大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求
- 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错
- 支持主键自动生成：支持 2 种主键策略，可自由配置，完美解决主键问题
- 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作
- 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）
- 内置分页插件：基于 RestHighLevelClient 物理分页，开发者无需关心具体操作，且无需额外配置插件，写分页等同于普通 List 查询, 且保持和 PageHelper 插件同样的分页返回字段, 无需担心命名影响
- MySQL 功能全覆盖: MySQL 中支持的功能通过 EE 都可以轻松实现
- 支持 ES 高阶语法: 支持高亮搜索, 分词查询, 权重查询, Geo 地理位置查询, IP 查询, 聚合查询等高阶语法
- 良好的拓展性: 底层仍使用 RestHighLevelClient, 可保持其拓展性, 开发者在使用 EE 的同时, 仍可使用 RestHighLevelClient 的功能

## Easy Es 框架架构

![image-20221118145141576](https://img2022.cnblogs.com/blog/2105804/202211/2105804-20221118145142858-56636605.png)

## Easy Es 避坑指南

在正式使用 EE 之前, 不妨花三五分钟学习一下, 可以帮各位在使用中避免踩坑, 从而节省大量时间. 遇到问题尽量先从 `使用角度`, `是否规范`, `版本是否兼容`, 去下手, 我们已提供的 API 都是有测试用例覆盖, 单测覆盖率高达 95%+, 并有社区大量用户以及生产环境实测佐证无缺陷的, 不要做键盘侠, 喷子, 上来就觉得框架遍地都是 Bug, 各种喷, 实际上是自己菜的抠脚... 要么不看文档瞎 j* 用, 要么是 ES 基础太差踩了 ES 的坑. 这类用户其实对自己技术成长一点帮助都没有, 正确姿势应该是按文档规范使用, 并且遇到问题先 debug, 看看源码, 问问度娘等多方途径.

### ES 版本及 SpringBoot 版本

由于底层用了 ES 官方的 RestHighLevelClient, 所以对 ES 版本有要求, 底层用的 RestHighLevelClient 版本为 `7.14`, 所以对 `7.14` 的 es 兼容性最好, 目前实测下来 ES 版本为 7.x 都可以兼容.

有不少基础比较差的开发者, 在引入了 EE 后还引入了其它一些 ES 依赖, 比如 SpringData 或其它 ES 依赖, 导致项目中实际引入的 ES 版本不是 7.x, 最终使用时出现各种 API 不兼容的问题, 甚至无法启动.

抱怨我们框架有缺陷, 实际上是依赖被覆盖引发的兼容性问题, 如果您不想浪费太多时间在 API 兼容问题上, 我们强烈建议您在使用前务必检查 ES 相关依赖的版本号是否为 7.x

### ES 索引的 keyword 类型和 text 类型以及 termQuery, match, match_phrase 区别：

![6b9f24cf-7eb9-43ac-9b65-86c3b759cd69](https://img2022.cnblogs.com/blog/2105804/202211/2105804-20221118150149314-542167449.png)

对 ES 索引类型以及以上查询 API 已经了解的可直接跳过此段介绍.

ES 中的 keyword 类型, 和 MySQL 中的字段基本上差不多, 当我们需要对查询字段进行 `精确匹配`, `左模糊`, `右模糊`, `全模糊`, `排序聚合` 等操作时, 需要该字段的索引类型为 `keyword` 类型, 否则你会发现查询没有查出想要的结果, 甚至报错. 比如 EE 中常用的 API eq(), like(), distinct() 等都需要字段类型为 keyword 类型.

当我们需要对字段进行 `分词查询` 时, 需要该字段的类型为 `text` 类型, 并且指定分词器(不指定就用 ES 默认分词器, 效果通常不理想). 比如 EE 中常用的API match() 等都需要字段类型为 text 类型. 当使用 match 查询时未查询到预期结果时, 可以先检查索引类型, 然后再检查分词器, 因为如果一个词没被分词器分出来, 那结果也是查询不出来的.

当同一个字段, 我们既需要把它当 keyword 类型使用, 又需要把它当 text 类型使用时, 此时我们的索引类型为 keyword_text 类型, EE 中可以对字段添加注解 `@TableField(fieldType = FieldType.KEYWORD_TEXT)`, 如此该字段就会被创建为 keyword+text 双类型如下图所示, 值得注意的是, 当我们把该字段当做 keyword 类型查询时, ES 要求传入的字段名称为 "字段名.keyword", 当把该字段当 text 类型查询时, 直接使用原字段名即可.

![72818af6-7cc3-4833-b7a7-dbff845ce73e](https://img2022.cnblogs.com/blog/2105804/202211/2105804-20221118151157132-1385179881.png)

另一种做法是, 可以冗余一个字段, 值用相同的, 一个注解标记为 keyword 类型, 另一个标记为 text 类型, 查询时按规则选择对应字段进行查询.

还需要注意的是, 如果一个字段的索引类型被创建为仅为 keyword 类型(如下图所示)查询时, 则不需要在其名称后面追加 .keyword, 直接查询就行.

![87335e55-1fe3-44ed-920b-61354383e85a](https://img2022.cnblogs.com/blog/2105804/202211/2105804-20221118151438226-962558908.png)

### 字段 id

由于框架很多功能都是借助 id 实现的, 比如 selectById, update, deleteById ..., 而且 ES 中也必须有一列作为数据 id, 因此我们强制要求用户封装的实体类中包含字段 id 列, 否则框架不少功能无法正常使用.

```java
public class Document {
    /**
     * es 中的唯一 id, 如果你想自定义 es 中的 id 为你提供的 id, 比如 MySQL 中的 id, 请将注解中的 type 指定为 customize 或直接在全局配置文件中指定, 如此 id 便支持任意数据类型)
     */
    @TableId(type = IdType.CUSTOMIZE)
    private String id;
}
```

如果不添加 `@TableId` 注解或者添加了注解但未指定 type, 则 id 默认为 es 自动生成的 id.

在调用 insert 方法时, 如果该 id 数据在 es 中不存在, 则新增该数据, 如果已有该 id 数据, 则即便你调用的是 insert 方法, 实际上的效果也是更新该 id 对应的数据, 这点需要区别于 MP 和 MySQL.

### 项目中同时使用 Mybatis-Plus 和 Easy-Es

在此场景下, 您需要将 MP 的 mapper 和 EE 的 mapper 分别放在不同的目录下, 并在配置扫描路径时各自配各自的扫描路径, 如此便可共存使用了, 否则两者在 SpringBoot 启动时都去扫描同一路径, 并尝试注册为自己的 bean, 由于底层实现依赖的类完全不一样, 所以会导致其中之一注册失败, 整个项目无法正常启动. 可参考下图:

![30f08bc4-cb07-4ac6-8a52-59e062105238](https://img2022.cnblogs.com/blog/2105804/202211/2105804-20221118152401136-1411463564.png)

![1b5806d4-6c5b-48e6-a025-7746f89f0f6a](https://img2022.cnblogs.com/blog/2105804/202211/2105804-20221118152459895-1555608492.png)

### and 和 or 的使用

需要区别于 MySQL 和 MP, 因为 ES 的查询参数是树形数据结构, 和 MySQL 平铺的不一样, 具体可参考条件构造器 `-and&or` 章节, 有详细介绍.